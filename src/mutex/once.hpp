//  Copyright (c) 2024- David Lucius Severus
//
//  Distributed under the Boost Software License, Version 1.0.
//  See accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt
#pragma once     // hehe

#include "../memory/actions.hpp"
#include "barrier.hpp"
#include "mutex.hpp"

// NOTE: moved from /sync to /mutex

namespace micron
{
// naming it like this to avoid ridiculous conflicts
template <auto F> class do_once
{

  // NOTE: the way this works is that for each and every unique function F, a new class will be generated by the
  // compiler, and likewise, a static atomic_token will be created per class. as such, each function will only be able to
  // execute once per runtime, otherwise the lock will prevent it from doing so. WARN: try not to use this too much since
  // it will baloon your bin size
  static auto &
  _lock(void)
  {
    static atomic_token<bool> alock(ATOMIC_OPEN);
    return alock;
  }

public:
  ~do_once() {}

  template <typename... Args> do_once(Args &&...args)
  {
    full_barrier();
    for ( ;; ) {
      while ( _lock().get() ) {
        return;
      }
      if ( !_lock().swap(ATOMIC_LOCKED) ) {
        F(micron::forward<Args>(args)...);
      }
    }
  }

  // delete everything else explicitly
  do_once(void) = delete;
  do_once(const do_once &) = delete;
  do_once(do_once &&) = delete;
  do_once &operator=(do_once &&) = delete;
  do_once &operator=(const do_once &) = delete;
};
};     // namespace micron
